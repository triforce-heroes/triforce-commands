import e from"node:assert";import{EntryCommand as t}from"./EntryCommand.js";import{EntryCompressed as n}from"./EntryCompressed.js";import{EntryText as s}from"./EntryText.js";let r=/\s*<\s*(\d+)\s*>\s*/g,o=/(\n+|\s{2,}|\p{So}|\s*(?:<\d+>){2,}\s*|\s+<\d+>\s*|\s*<\d+>\s+|^\s+|\s+$)/u,i=/(\p{So}|(?:<\d+>){2,}$)/u,a=/(?:<\s*\d+\s*>)+/g,l=/\s+/g,d=/[^\p{L}\p{N}\p{Pc}\p{Po}\p{Pd}\s<>]+/gu;export class Entries{constructor(e){this.entries=e}toText(){let r=new Map,o="";for(let i of this.entries){if(i instanceof s){o+=i.text;continue}if(i instanceof n){o+=`<${i.index}>`;continue}e(i instanceof t),r.has(i.command)||r.set(i.command,{index:r.size+1,entry:i}),o+=`<${r.get(i.command).index}>`}return o}toTranslation(e=!1){let t=new Map,r=[],a=this.toText().split(e?i:o);for(let e=0;e<a.length;e+=2){let o=a[e];""!==o&&r.push(new s(o));let i=a[e+1];void 0!==i&&(t.has(i)||t.set(i,{index:t.size+1,entry:new n(t.size+1,i)}),r.push(t.get(i).entry))}return new Entries(r)}toIndex(){let e=new Map;return new Entries([new s(this.toTranslation(!0).toText())]).toText().replaceAll(a,t=>(e.has(t)||e.set(t,{index:e.size+1,entry:new n(e.size+1,t)}),`<${e.get(t).index}>`)).replaceAll(d," ").replaceAll(l," ").trim()}toRaw(){return this.entries.map(e=>e.toString()).join("")}fromTranslation(e){let t=this.getCommandIndexes();return e.replaceAll(r,(e,n)=>{let s=t.get(Number(n));return void 0===s?`<${n}>`:s.contents})}getCommandIndexes(){let e=new Map;for(let t of this.entries)t instanceof n&&e.set(t.index,t);return e}}