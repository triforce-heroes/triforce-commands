import{EntryCommand as e}from"./EntryCommand.js";import{EntryCompressed as t}from"./EntryCompressed.js";import{EntryText as n}from"./EntryText.js";let s=/\s*<\s*(\d+)\s*>\s*/g,r=/<(\d+)>/g,o=/(\n+|\s{2,}|\p{So}|\s*(?:<\d+>)+\s*|^\s+|\s+$)/u,i=/(\p{So}|(?:<\d+>){2,}$)/u,l=/(?:<\s*\d+\s*>)+/g,d=/\s+/g,p=/[^\p{L}\p{N}\p{Pc}\p{Po}\p{Pd}\s<>]+/gu;export class Entries{constructor(e){this.entries=e}toText(){let s=new Map,r="";for(let o of this.entries){if(o instanceof n){r+=o.text;continue}if(o instanceof t){r+=`<${o.index}>`;continue}o instanceof e&&(s.has(o.command)||s.set(o.command,{index:s.size+1,entry:o}),r+=`<${s.get(o.command).index}>`)}return r}toCompressed(e=!1){let s=new Map,r=[],l=this.toText().split(e?i:o);for(let e=0;e<l.length;e+=2){let o=l[e];""!==o&&r.push(new n(o));let i=l[e+1];void 0!==i&&(s.has(i)||s.set(i,{index:s.size+1,entry:new t(s.size+1,i)}),r.push(s.get(i).entry))}return new Entries(r)}toIndex(){let e=new Map;return new Entries([new n(this.toCompressed(!0).toText())]).toText().replaceAll(l,n=>(e.has(n)||e.set(n,{index:e.size+1,entry:new t(e.size+1,n)}),`<${e.get(n).index}>`)).replaceAll(p," ").replaceAll(d," ").trim()}toRaw(){return this.entries.map(e=>e.toString()).join("")}fromCompressed(n,o){let i=new Map;for(let e of this.entries)e instanceof t&&i.set(e.index,e);let l=n.replaceAll(s,(e,t)=>{let n=i.get(Number(t));return void 0===n?`<${t}>`:n.contents});if(void 0===o)return l;let d=new Set;for(let t of o.entries)t instanceof e&&d.add(t.command);let p=[...d.values()];return l.replaceAll(r,(e,t)=>p[t-1]??`<${t}>`)}}