import{EntryCommand as e}from"./EntryCommand.js";import{EntryCompressed as t}from"./EntryCompressed.js";import{EntryText as n}from"./EntryText.js";let s=/\s*<\s*(\d+)\s*>\s*/g,r=/<(\d+)>/g,i=/(\n+|\s{2,}|\p{So}|\s*(?:<\d+>)+\s*|^\s+|\s+$)/u,o=/(\p{So}|(?:<\d+>){2,}$)/u,l=/(?:<\s*\d+\s*>)+/g,d=/\s+/g,p=/[^\p{L}\p{N}\p{Pc}\p{Po}\p{Pd}\s<>]+/gu;export class Entries{constructor(e){this.entries=e}toText(){let s=new Map,r="";for(let i of this.entries){if(i instanceof n){r+=i.text;continue}if(i instanceof t){r+=`<${String(i.index)}>`;continue}i instanceof e&&(s.has(i.command)||s.set(i.command,{index:s.size+1,entry:i}),r+=`<${String(s.get(i.command).index)}>`)}return r}toCompressed(e=!1){let s=new Map,r=[],l=this.toText().split(e?o:i);for(let e=0;e<l.length;e+=2){let i=l[e];""!==i&&r.push(new n(i));let o=l[e+1];void 0!==o&&(s.has(o)||s.set(o,{index:s.size+1,entry:new t(s.size+1,o)}),r.push(s.get(o).entry))}return new Entries(r)}toIndex(){let e=new Map;return new Entries([new n(this.toCompressed(!0).toText())]).toText().replaceAll(l,n=>(e.has(n)||e.set(n,{index:e.size+1,entry:new t(e.size+1,n)}),`<${String(e.get(n).index)}>`)).replaceAll(p," ").replaceAll(d," ").trim()}toRaw(){return this.entries.map(e=>e.toString()).join("")}fromCompressed(n,i){let o=new Map;for(let e of this.entries)e instanceof t&&o.set(e.index,e);let l=n.replaceAll(s,(e,t)=>{let n=o.get(Number(t));return void 0===n?`<${String(t)}>`:n.contents});if(void 0===i)return l;let d=new Set;for(let t of i.entries)t instanceof e&&d.add(t.command);let p=[...d.values()];return l.replaceAll(r,(e,t)=>p[t-1]??`<${String(t)}>`)}}