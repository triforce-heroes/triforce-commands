import e from"node:assert";import{EntryCommand as t}from"./EntryCommand.js";import{EntryCompressed as n}from"./EntryCompressed.js";import{EntryText as s}from"./EntryText.js";let r=/\s*<\s*(\d+)\s*>\s*/g,o=/<(\d+)>/g,i=/(\n+|\s{2,}|\p{So}|\s*(?:<\d+>)+\s*|^\s+|\s+$)/u,l=/(\p{So}|(?:<\d+>){2,}$)/u,d=/(?:<\s*\d+\s*>)+/g,p=/\s+/g,a=/[^\p{L}\p{N}\p{Pc}\p{Po}\p{Pd}\s<>]+/gu;export class Entries{constructor(e){this.entries=e}toText(){let r=new Map,o="";for(let i of this.entries){if(i instanceof s){o+=i.text;continue}if(i instanceof n){o+=`<${i.index}>`;continue}e(i instanceof t),r.has(i.command)||r.set(i.command,{index:r.size+1,entry:i}),o+=`<${r.get(i.command).index}>`}return o}toCompressed(e=!1){let t=new Map,r=[],o=this.toText().split(e?l:i);for(let e=0;e<o.length;e+=2){let i=o[e];""!==i&&r.push(new s(i));let l=o[e+1];void 0!==l&&(t.has(l)||t.set(l,{index:t.size+1,entry:new n(t.size+1,l)}),r.push(t.get(l).entry))}return new Entries(r)}toIndex(){let e=new Map;return new Entries([new s(this.toCompressed(!0).toText())]).toText().replaceAll(d,t=>(e.has(t)||e.set(t,{index:e.size+1,entry:new n(e.size+1,t)}),`<${e.get(t).index}>`)).replaceAll(a," ").replaceAll(p," ").trim()}toRaw(){return this.entries.map(e=>e.toString()).join("")}fromCompressed(e,s){let i=new Map;for(let e of this.entries)e instanceof n&&i.set(e.index,e);let l=e.replaceAll(r,(e,t)=>{let n=i.get(Number(t));return void 0===n?`<${t}>`:n.contents});if(void 0===s)return l;let d=new Set;for(let e of s.entries)e instanceof t&&d.add(e.command);let p=[...d.values()];return l.replaceAll(o,(e,t)=>p[t-1]??`<${t}>`)}}